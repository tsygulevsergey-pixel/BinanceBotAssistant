// @version=5
// Adaptive Market Flow Strategy V2
// Концепция: Адаптивная стратегия с ATR-нормализацией и умными фильтрами
strategy("Adaptive Market Flow V2", overlay=true, 
         initial_capital=10000, default_qty_type=strategy.percent_of_equity, 
         default_qty_value=100, commission_type=strategy.commission.percent, 
         commission_value=0.04)

// ==================== ПАРАМЕТРЫ ====================

// Adaptive Settings
volatility_lookback = input.int(14, "Volatility Lookback", minval=5, maxval=30)
adaptive_zone_mult = input.float(1.5, "Zone ATR Multiplier", minval=0.5, maxval=3.0, step=0.1)

// EMA Settings (фиксированные, но используем адаптивно)
use_fast_mode = input.bool(true, "Use Fast Mode in High Volatility")
ema_fast_normal = input.int(9, "EMA Fast (Normal)", minval=3, maxval=20)
ema_slow_normal = input.int(21, "EMA Slow (Normal)", minval=10, maxval=50)
ema_fast_volatile = input.int(6, "EMA Fast (Volatile)", minval=3, maxval=15)
ema_slow_volatile = input.int(15, "EMA Slow (Volatile)", minval=8, maxval=30)

// Entry Thresholds
min_momentum_strength = input.float(1.2, "Min Momentum Strength", minval=0.5, maxval=3.0, step=0.1)
min_volume_ratio = input.float(1.3, "Min Volume Ratio", minval=1.0, maxval=3.0, step=0.1)

// Risk Management
use_trailing_stop = input.bool(true, "Use Trailing Stop")
risk_reward_ratio = input.float(2.0, "Risk/Reward Ratio", minval=1.0, maxval=5.0, step=0.5)

// ==================== VOLATILITY DETECTION ====================

// ATR для адаптации
atr = ta.atr(volatility_lookback)
atr_pct = (atr / close) * 100

// Определяем волатильность
atr_ma = ta.sma(atr, 50)
volatility_ratio = atr / atr_ma

is_high_volatility = volatility_ratio > 1.3
is_low_volatility = volatility_ratio < 0.7
is_normal_volatility = not is_high_volatility and not is_low_volatility

// ==================== ADAPTIVE EMA ====================

// Выбираем EMA в зависимости от волатильности
ema_fast = use_fast_mode and is_high_volatility ? ta.ema(close, ema_fast_volatile) : ta.ema(close, ema_fast_normal)
ema_slow = use_fast_mode and is_high_volatility ? ta.ema(close, ema_slow_volatile) : ta.ema(close, ema_slow_normal)

// Дополнительный фильтр тренда
ema_trend = ta.ema(close, 50)

// ==================== VOLUME ====================

volume_ma = ta.sma(volume, 20)
volume_ratio = volume / volume_ma

// ==================== MARKET STATE ====================

// Определяем тренд/флет
price_range = ta.highest(high, 20) - ta.lowest(low, 20)
price_range_ma = ta.sma(price_range, 20)
market_efficiency = price_range / price_range_ma

is_trending = market_efficiency > 1.2
is_ranging = market_efficiency < 0.8

// ==================== ATR-NORMALIZED MOMENTUM ====================

// Универсальный momentum (работает на любой монете!)
raw_momentum = close - close[3]
atr_normalized_momentum = raw_momentum / atr

// Сила и направление
momentum_strength = math.abs(atr_normalized_momentum)
momentum_bullish = atr_normalized_momentum > 0
momentum_bearish = atr_normalized_momentum < 0

// ==================== DYNAMIC ZONES ====================

// Адаптивные зоны на основе ATR
middle_zone = ta.ema(close, 20)
upper_zone = middle_zone + atr * adaptive_zone_mult
lower_zone = middle_zone - atr * adaptive_zone_mult

// Breakout detection
upper_breakout = close > upper_zone and close[1] <= upper_zone[1]
lower_breakout = close < lower_zone and close[1] >= lower_zone[1]

// Pullback к зонам (дополнительная логика)
pullback_to_middle = math.abs(close - middle_zone) < atr * 0.5

// ==================== SCORING SYSTEM ====================

calc_long_score() =>
    score = 0.0
    
    // 1. Momentum (главное!)
    if momentum_bullish and momentum_strength > min_momentum_strength
        score := score + 3.0
    else if momentum_bullish and momentum_strength > min_momentum_strength * 0.7
        score := score + 1.5
    
    // 2. EMA alignment
    if ema_fast > ema_slow
        score := score + 1.5
    
    // 3. Trend filter
    if close > ema_trend
        score := score + 1.0
    
    // 4. Volume
    if volume_ratio > min_volume_ratio
        score := score + 1.5
    else if volume_ratio > min_volume_ratio * 0.8
        score := score + 0.5
    
    // 5. Zone breakout/pullback
    if upper_breakout
        score := score + 1.0
    else if pullback_to_middle and close > middle_zone
        score := score + 0.5
    
    // 6. Market state bonus
    if is_trending and ema_fast > ema_slow
        score := score + 1.0
    else if is_ranging and lower_breakout
        score := score + 0.5
    
    score

calc_short_score() =>
    score = 0.0
    
    if momentum_bearish and momentum_strength > min_momentum_strength
        score := score + 3.0
    else if momentum_bearish and momentum_strength > min_momentum_strength * 0.7
        score := score + 1.5
    
    if ema_fast < ema_slow
        score := score + 1.5
    
    if close < ema_trend
        score := score + 1.0
    
    if volume_ratio > min_volume_ratio
        score := score + 1.5
    else if volume_ratio > min_volume_ratio * 0.8
        score := score + 0.5
    
    if lower_breakout
        score := score + 1.0
    else if pullback_to_middle and close < middle_zone
        score := score + 0.5
    
    if is_trending and ema_fast < ema_slow
        score := score + 1.0
    else if is_ranging and upper_breakout
        score := score + 0.5
    
    score

// ==================== ENTRY CONDITIONS ====================

long_score = calc_long_score()
short_score = calc_short_score()

// Адаптивный минимум
min_entry_score = is_trending ? 4.0 : 5.0

long_condition = long_score >= min_entry_score and strategy.position_size == 0
short_condition = short_score >= min_entry_score and strategy.position_size == 0

// ==================== POSITION MANAGEMENT ====================

// LONG Entry & Exit
if long_condition
    long_sl = close - atr * 1.5
    long_tp = close + (close - long_sl) * risk_reward_ratio
    
    strategy.entry("Long", strategy.long)
    
    if use_trailing_stop
        strategy.exit("Exit Long", from_entry="Long", limit=long_tp, trail_price=close, trail_offset=atr * 1.5)
    else
        strategy.exit("Exit Long", from_entry="Long", limit=long_tp, stop=long_sl)

// SHORT Entry & Exit
if short_condition
    short_sl = close + atr * 1.5
    short_tp = close - (short_sl - close) * risk_reward_ratio
    
    strategy.entry("Short", strategy.short)
    
    if use_trailing_stop
        strategy.exit("Exit Short", from_entry="Short", limit=short_tp, trail_price=close, trail_offset=atr * 1.5)
    else
        strategy.exit("Exit Short", from_entry="Short", limit=short_tp, stop=short_sl)

// Momentum reversal exit
if strategy.position_size > 0 and momentum_bearish and momentum_strength > 1.8
    strategy.close("Long", comment="Momentum Reversal")

if strategy.position_size < 0 and momentum_bullish and momentum_strength > 1.8
    strategy.close("Short", comment="Momentum Reversal")

// ==================== VISUALIZATION ====================

// Dynamic zones
plot(upper_zone, "Upper Zone", color=color.new(color.red, 70), linewidth=2)
plot(middle_zone, "Middle", color=color.new(color.gray, 70), linewidth=1)
plot(lower_zone, "Lower Zone", color=color.new(color.green, 70), linewidth=2)

// EMA
plot(ema_fast, "EMA Fast", color=color.orange, linewidth=2)
plot(ema_slow, "EMA Slow", color=color.blue, linewidth=2)
plot(ema_trend, "EMA Trend", color=color.purple, linewidth=1)

// Market state background
market_bg = is_trending ? color.new(color.green, 95) : is_ranging ? color.new(color.orange, 95) : color.new(color.gray, 98)
bgcolor(market_bg, title="Market State")

// Volume highlighting
barcolor(volume_ratio > min_volume_ratio ? color.new(color.yellow, 60) : na)

// Entry signals
if long_condition
    label.new(bar_index, low, "LONG\n" + str.tostring(long_score, "#.#") + "\nATR: " + str.tostring(atr_pct, "#.##") + "%", style=label.style_label_up, color=color.new(color.green, 20), textcolor=color.white, size=size.normal)

if short_condition
    label.new(bar_index, high, "SHORT\n" + str.tostring(short_score, "#.#") + "\nATR: " + str.tostring(atr_pct, "#.##") + "%", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white, size=size.normal)

// Momentum indicator
hline(0, "Zero", color=color.gray, linestyle=hline.style_dashed)
plot(atr_normalized_momentum, "Momentum", color=atr_normalized_momentum > 0 ? color.green : color.red, linewidth=2, style=plot.style_histogram)

// ==================== INFO TABLE ====================

var table info = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 85), border_width=1)

if barstate.islast
    table.cell(info, 0, 0, "Market", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 0, is_trending ? "TREND" : is_ranging ? "RANGE" : "NEUTRAL", text_color=is_trending ? color.green : is_ranging ? color.orange : color.gray, text_size=size.small)
    
    table.cell(info, 0, 1, "Volatility", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 1, is_high_volatility ? "HIGH" : is_low_volatility ? "LOW" : "NORMAL", text_color=is_high_volatility ? color.red : is_low_volatility ? color.blue : color.gray, text_size=size.small)
    
    table.cell(info, 0, 2, "ATR%", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 2, str.tostring(atr_pct, "#.##") + "%", text_color=color.yellow, text_size=size.small)
    
    table.cell(info, 0, 3, "EMA Mode", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 3, use_fast_mode and is_high_volatility ? "FAST" : "NORMAL", text_color=use_fast_mode and is_high_volatility ? color.orange : color.blue, text_size=size.small)
    
    table.cell(info, 0, 4, "Momentum", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 4, str.tostring(atr_normalized_momentum, "#.##"), text_color=atr_normalized_momentum > 0 ? color.green : color.red, text_size=size.small)
    
    table.cell(info, 0, 5, "Volume", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 5, str.tostring(volume_ratio, "#.##") + "x", text_color=volume_ratio > min_volume_ratio ? color.green : color.gray, text_size=size.small)
    
    table.cell(info, 0, 6, "Min Score", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 6, str.tostring(min_entry_score, "#.#"), text_color=color.white, text_size=size.small)
    
    table.cell(info, 0, 7, "Long/Short", text_color=color.white, text_size=size.small)
    table.cell(info, 1, 7, str.tostring(long_score, "#.#") + " / " + str.tostring(short_score, "#.#"), text_color=color.gray, text_size=size.small)
