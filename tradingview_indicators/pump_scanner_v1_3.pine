// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=5
indicator("Pump Scanner v1.3 (Dual Path: Compression + FIT)", overlay=true, max_labels_count=50)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹
emaLen200 = input.int(200, "EMA200 Length", minval=1, group="EMA & Ribbons")
atrLen = input.int(14, "ATR Length", minval=1, group="ATR Channels")
atrMult = input.float(2.0, "ATR Multiplier", minval=0.1, group="ATR Channels")

bbLen = input.int(20, "BB Length", minval=1, group="Bollinger & Keltner")
bbMult = input.float(2.0, "BB Multiplier", minval=0.1, group="Bollinger & Keltner")
kcLen = input.int(20, "KC Length", minval=1, group="Bollinger & Keltner")
kcMult = input.float(1.5, "KC Multiplier", minval=0.1, group="Bollinger & Keltner")

volLen = input.int(50, "Volume SMA Length", minval=1, group="Volume & CVD")
volZThreshold = input.float(2.0, "Volume Z-Score Threshold", minval=0.5, group="Volume & CVD")
lrLen = input.int(50, "CVD Linear Regression Length", minval=1, group="Volume & CVD")

swingLen = input.int(20, "Swing Length", minval=1, group="Swing High/Low")

// PATH A: ĞšĞ¾Ğ¼Ğ¿Ñ€ĞµÑÑĞ¸Ñ â†’ Ğ’Ñ‹Ñ…Ğ¾Ğ´
bbWidthZThreshold = input.float(-0.8, "BBWidth Z-Score Threshold", minval=-2.0, maxval=0.0, step=0.1, group="Path A: Compression")
atrPctZThreshold = input.float(-0.5, "ATR% Z-Score Threshold", minval=-2.0, maxval=0.0, step=0.1, group="Path A: Compression")
compressionMinSigns = input.int(2, "Compression Min Signs (of 3)", minval=1, maxval=3, group="Path A: Compression")
compressionPersistN = input.int(3, "Compression Persist (N of M)", minval=2, maxval=10, group="Path A: Compression")
compressionPersistM = input.int(6, "Compression Lookback (M bars)", minval=3, maxval=20, group="Path A: Compression")
ribbonTightThr = input.float(0.22, "Ribbon Tight (ATR)", minval=0.05, step=0.01, group="Path A: Compression")
distTo200Thr = input.float(0.25, "Distance to EMA200 (ATR)", minval=0.05, step=0.05, group="Path A: Compression")
slopeFlatThr = input.float(0.01, "EMA200 Flat Slope Tolerance", minval=0.0, step=0.01, group="Path A: Compression")
volDryThreshold = input.float(0.8, "Volume Dry Ratio", minval=0.5, maxval=1.0, step=0.05, group="Path A: Compression")

// PATH A: Trigger Settings
watchMinScore = input.int(5, "Watch Min Score", minval=1, maxval=10, group="Path A: Trigger")
triggerDepthMin = input.float(0.30, "Trigger Depth (ATR)", minval=0.1, step=0.05, group="Path A: Trigger")
triggerAirMin = input.float(0.30, "Trigger Air to Band (ATR)", minval=0.1, step=0.05, group="Path A: Trigger")
triggerVolZ = input.float(2.0, "Trigger Volume Z-Score", minval=1.0, step=0.5, group="Path A: Trigger")
debounceBarCount = input.int(2, "Watch Debounce (bars)", minval=1, maxval=5, group="Path A: Trigger")
triggerCooldown = input.int(25, "Trigger Cooldown (bars)", minval=10, maxval=60, group="Path A: Trigger")
enablePreTouchFilter = input.bool(true, "Enable Pre-Touch Filter", group="Path A: Trigger")

// PATH B: FIT (First-Impulse Trigger)
enableFIT = input.bool(true, "Enable FIT Path", group="Path B: FIT")
fitTRmult = input.float(1.8, "FIT TrueRange / ATR", minval=1.0, step=0.1, group="Path B: FIT")
fitBodyMult = input.float(1.2, "FIT Body / ATR", minval=0.5, step=0.1, group="Path B: FIT")
fitVolZ = input.float(3.0, "FIT Volume Z-Score", minval=2.0, step=0.5, group="Path B: FIT")
fitVolPercentile = input.int(95, "FIT Volume Percentile", minval=90, maxval=99, group="Path B: FIT")
fitDepthMin = input.float(0.25, "FIT Depth from EMA200 (ATR)", minval=0.1, step=0.05, group="Path B: FIT")
fitBBexpansion = input.float(1.8, "FIT BBWidth Expansion", minval=1.2, step=0.1, group="Path B: FIT")
fitAirMin = input.float(0.20, "FIT Air to Band (ATR)", minval=0.1, step=0.05, group="Path B: FIT")
fitCooldown = input.int(40, "FIT Cooldown (bars)", minval=20, maxval=80, group="Path B: FIT")

// Advanced Filters
enableHTFbias = input.bool(false, "Enable 1H HTF Bias Filter", group="Advanced Filters")
enableRegimeFilter = input.bool(false, "Disable if ATR% Z > 1.0 (Wide Market)", group="Advanced Filters")
maxDistFromEMA = input.float(1.1, "Max Distance from EMA200 (ATR)", minval=0.5, step=0.1, group="Advanced Filters")

// ĞĞ¿Ñ†Ğ¸Ğ¸
enableShorts = input.bool(false, "Enable Short Triggers", group="Options")
showPanel = input.bool(true, "Show Info Panel", group="Options")
showWatchBg = input.bool(true, "Show Watch Background", group="Options")
showTriggerBg = input.bool(true, "Show Trigger Background", group="Options")
lookbackBW = input.int(200, "BBWidth/ATR Z-Score Lookback", minval=50, group="Options")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ ĞĞ¡Ğ§ĞĞ¢Ğ«
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// EMA200 Ğ¸ Ğ½Ğ°ĞºĞ»Ğ¾Ğ½
ema200 = ta.ema(close, emaLen200)
atr14 = ta.atr(atrLen)
slope200 = nz((ema200 - ema200[1]) / atr14, 0)

// EMA Ribbon
ema5 = ta.ema(close, 5)
ema9 = ta.ema(close, 9)
ema13 = ta.ema(close, 13)
ema21 = ta.ema(close, 21)

// Bollinger Bands
bbBasis = ta.sma(close, bbLen)
bbDev = ta.stdev(close, bbLen)
bbUpper = bbBasis + bbMult * bbDev
bbLower = bbBasis - bbMult * bbDev
bbWidth = nz((bbUpper - bbLower) / bbBasis, 0)

// Keltner Channel
kcMid = ta.ema(close, kcLen)
kcRange = ta.atr(kcLen)
kcUpper = kcMid + kcMult * kcRange
kcLower = kcMid - kcMult * kcRange

// TTM Squeeze
squeezeOn = (bbLower > kcLower) and (bbUpper < kcUpper)

// BBWidth Z-Score
bbWidthSMA = ta.sma(bbWidth, lookbackBW)
bbWidthStd = ta.stdev(bbWidth, lookbackBW)
bbWidthZ = nz((bbWidth - bbWidthSMA) / bbWidthStd, 0)

// ATR% Z-Score
atrPct = nz(atr14 / close * 100, 0)
atrPctSMA = ta.sma(atrPct, lookbackBW)
atrPctStd = ta.stdev(atrPct, lookbackBW)
atrPctZ = nz((atrPct - atrPctSMA) / atrPctStd, 0)

// ĞšĞ¾Ğ¼Ğ¿Ñ€ĞµÑÑĞ¸Ñ (Ğ³Ğ¸Ğ±ĞºĞ°Ñ: N Ğ¸Ğ· 3)
compressionSign1 = squeezeOn
compressionSign2 = bbWidthZ < bbWidthZThreshold
compressionSign3 = atrPctZ < atrPctZThreshold
compressionSignsCount = (compressionSign1 ? 1 : 0) + (compressionSign2 ? 1 : 0) + (compressionSign3 ? 1 : 0)
trueCompression = compressionSignsCount >= compressionMinSigns

// Swing High/Low
swingHigh = ta.highest(high, swingLen)
swingLow = ta.lowest(low, swingLen)

// Volume
volSMA = ta.sma(volume, volLen)
volStd = ta.stdev(volume, volLen)
volZ = nz((volume - volSMA) / volStd, 0)
volSpike = volZ >= volZThreshold
volDry = nz(volume / volSMA, 1.0) < volDryThreshold

// Volume Percentile (Ğ´Ğ»Ñ FIT)
vol95 = ta.percentile_nearest_rank(volume, 90, fitVolPercentile)

// ĞŸÑĞµĞ²Ğ´Ğ¾-CVD
signedVol = volume * math.sign(close - close[1])
var float cvd = 0
cvd += signedVol
cvdSlope = ta.linreg(cvd, lrLen, 0) - ta.linreg(cvd, lrLen, 1)

// Ribbon Tight
ribbonMax = math.max(ema5, ema9, ema13, ema21)
ribbonMin = math.min(ema5, ema9, ema13, ema21)
ribbonSpan = ribbonMax - ribbonMin
ribbonTight = nz(ribbonSpan / atr14, 0) <= ribbonTightThr

// HTF Bias (1H EMA200)
ema200_1h = request.security(syminfo.tickerid, "60", ta.ema(close, 200))
htfBullish = close >= ema200_1h
htfBearish = close <= ema200_1h

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATH A: ĞšĞĞœĞŸĞ Ğ•Ğ¡Ğ¡Ğ˜Ğ¯ â†’ Ğ’Ğ«Ğ¥ĞĞ”
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ĞŸĞµÑ€ÑĞ¸ÑÑ‚ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒ ĞºĞ¾Ğ¼Ğ¿Ñ€ĞµÑÑĞ¸Ğ¸ (â‰¥N Ğ¸Ğ· M Ğ±Ğ°Ñ€Ğ¾Ğ²)
compressionCount = 0
for i = 0 to compressionPersistM - 1
    if trueCompression[i]
        compressionCount += 1

persistentCompression = compressionCount >= compressionPersistN

// ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¾Ñ‚Ğ½Ğ¾ÑĞ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ EMA200
aboveEMA200 = close > ema200
belowEMA200 = close < ema200
distTo200ATR = nz((close - ema200) / atr14, 0)
nearEMA200 = math.abs(distTo200ATR) <= distTo200Thr

// Slope Ñ Ğ¿Ğ»Ğ¾ÑĞºĞ¾Ğ¹ Ğ·Ğ¾Ğ½Ğ¾Ğ¹ (v1.3: ÑĞ¼ÑĞ³Ñ‡Ğ¸Ğ»Ğ¸ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ)
slopeUpGood = slope200 >= -slopeFlatThr  // Long: Ğ´Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸ Ğ¿Ğ»Ğ¾ÑĞºĞ¸Ğ¹
slopeDownGood = slope200 <= slopeFlatThr  // Short: Ğ´Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸ Ğ¿Ğ»Ğ¾ÑĞºĞ¸Ğ¹

// ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Watch Score
score_compression = persistentCompression ? 3 : 0
score_ribbon = ribbonTight ? 2 : 0
score_near200 = nearEMA200 ? 1 : 0
score_volDry = volDry ? 1 : 0
score_cvdSlope = cvdSlope > 0 ? 1 : 0

// ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ ÑĞºĞ¾Ñ€
score_slopeLong = (aboveEMA200 and slopeUpGood) ? 2 : 0
score_slopeShort = (belowEMA200 and slopeDownGood) ? 2 : 0

watchScoreLong = score_compression + score_ribbon + score_near200 + score_volDry + score_cvdSlope + score_slopeLong
watchScoreShort = score_compression + score_ribbon + score_near200 + score_volDry - score_cvdSlope + score_slopeShort

// Ğ”Ğ¸Ñ€ĞµĞºÑ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Watch
isWatchLongRaw = aboveEMA200 and watchScoreLong >= watchMinScore
isWatchShortRaw = belowEMA200 and watchScoreShort >= watchMinScore and enableShorts

// Ğ”ĞµĞ±Ğ°ÑƒĞ½Ñ Ğ´Ğ»Ñ Watch
var int watchDebounceCounter = 0
if (isWatchLongRaw or isWatchShortRaw)
    watchDebounceCounter += 1
else
    watchDebounceCounter := 0

watchConfirmed = watchDebounceCounter >= debounceBarCount
isWatchLong = watchConfirmed and isWatchLongRaw
isWatchShort = watchConfirmed and isWatchShortRaw

// PATH A: Triggers
distToUpperBand = nz((bbUpper - close) / atr14, 0)
distToLowerBand = nz((close - bbLower) / atr14, 0)

// Pre-touch Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€
preTouchLong = enablePreTouchFilter and (low[1] <= ema200) and (distTo200ATR < 0.25)
preTouchShort = enablePreTouchFilter and (high[1] >= ema200) and (distTo200ATR > -0.25)

// Trigger Long (Path A)
breakoutLong = close > swingHigh
depthLong = distTo200ATR >= triggerDepthMin
airLong = distToUpperBand >= triggerAirMin
volumeConfirmLong = volZ >= triggerVolZ

isTriggerLongA = breakoutLong and depthLong and airLong and volumeConfirmLong and not preTouchLong

// Trigger Short (Path A)
breakoutShort = close < swingLow
depthShort = -distTo200ATR >= triggerDepthMin
airShort = distToLowerBand >= triggerAirMin
volumeConfirmShort = volZ >= triggerVolZ

isTriggerShortA = enableShorts and breakoutShort and depthShort and airShort and volumeConfirmShort and not preTouchShort

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATH B: FIT (First-Impulse Trigger)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 1. ĞĞ½Ğ¾Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ ÑĞ²ĞµÑ‡Ğ¸
trueRange = high - low
trRange_ATR = nz(trueRange / atr14, 0)
body_ATR = nz(math.abs(close - open) / atr14, 0)
fitAnomalyRange = (trRange_ATR >= fitTRmult) or (body_ATR >= fitBodyMult)

// 2. ĞĞ½Ğ¾Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼
fitAnomalyVol = (volZ >= fitVolZ) or (volume >= vol95)

// 3. Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğ¹ ÑĞ´Ğ²Ğ¸Ğ³ (EMA200 cross Ğ¸Ğ»Ğ¸ SwingBreak)
ema200CrossUp = ta.crossover(close, ema200) and (distTo200ATR >= fitDepthMin)
ema200CrossDown = ta.crossunder(close, ema200) and (-distTo200ATR >= fitDepthMin)
swingBreakUp = close > swingHigh
swingBreakDown = close < swingLow
fitStructuralLong = ema200CrossUp or swingBreakUp
fitStructuralShort = ema200CrossDown or swingBreakDown

// 4. Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ»Ğ°Ñ‚Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
bbWidthAvg5 = ta.sma(bbWidth, 5)
bbWidthExpansion = nz(bbWidth / bbWidthAvg5, 1.0)
fitBBexpanded = bbWidthExpansion >= fitBBexpansion

// 5. Ğ’Ğ¾Ğ·Ğ´ÑƒÑ… Ğ´Ğ¾ Ğ¿Ğ¾Ğ»Ğ¾ÑÑ‹
fitAirLong = distToUpperBand >= fitAirMin
fitAirShort = distToLowerBand >= fitAirMin

// 6. Pre-touch Ğ´Ğ»Ñ FIT (Ğ¼ÑĞ³ĞºĞ¸Ğ¹)
fitPreTouchLong = enablePreTouchFilter and (low[1] <= ema200) and (distTo200ATR < 0.30)
fitPreTouchShort = enablePreTouchFilter and (high[1] >= ema200) and (distTo200ATR > -0.30)

// FIT Long
isFITlongRaw = enableFIT and fitAnomalyRange and fitAnomalyVol and fitStructuralLong and fitBBexpanded and fitAirLong and not fitPreTouchLong

// FIT Short
isFITshortRaw = enableFIT and enableShorts and fitAnomalyRange and fitAnomalyVol and fitStructuralShort and fitBBexpanded and fitAirShort and not fitPreTouchShort

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COOLDOWN & FILTERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cooldown Path A
var int cooldownCounterA = 0
if (isTriggerLongA or isTriggerShortA)
    cooldownCounterA := triggerCooldown
if cooldownCounterA > 0
    cooldownCounterA -= 1

// Cooldown Path B (FIT)
var int cooldownCounterB = 0
if (isFITlongRaw or isFITshortRaw)
    cooldownCounterB := fitCooldown
if cooldownCounterB > 0
    cooldownCounterB -= 1

// Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ñ€Ğ¸Ğ³Ğ³ĞµÑ€Ñ‹ Ñ cooldown
canTriggerA = cooldownCounterA == 0 and cooldownCounterB == 0
canTriggerB = cooldownCounterB == 0 and cooldownCounterA == 0

isTriggerLong = isTriggerLongA and canTriggerA
isTriggerShort = isTriggerShortA and canTriggerA
isFITlong = isFITlongRaw and canTriggerB
isFITshort = isFITshortRaw and canTriggerB

// Advanced Filters
tooFarFromEMA = math.abs(distTo200ATR) > maxDistFromEMA
marketTooWide = enableRegimeFilter and (atrPctZ > 1.0)
htfFilterLong = enableHTFbias and not htfBullish
htfFilterShort = enableHTFbias and not htfBearish

// Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
blockLongSignals = tooFarFromEMA or marketTooWide or htfFilterLong
blockShortSignals = tooFarFromEMA or marketTooWide or htfFilterShort

// Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ğ¼Ğ¸
isTriggerLongFinal = isTriggerLong and not blockLongSignals
isTriggerShortFinal = isTriggerShort and not blockShortSignals
isFITlongFinal = isFITlong and not blockLongSignals
isFITshortFinal = isFITshort and not blockShortSignals

// Watch Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸ cooldown
isWatchLongFinal = isWatchLong and (cooldownCounterA == 0) and (cooldownCounterB == 0) and not blockLongSignals
isWatchShortFinal = isWatchShort and (cooldownCounterA == 0) and (cooldownCounterB == 0) and not blockShortSignals

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ’Ğ˜Ğ—Ğ£ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Plots
plot(ema200, "EMA200", color=color.new(color.orange, 30), linewidth=2)
plot(bbUpper, "BB Upper", color=color.new(color.blue, 80), linewidth=1)
plot(bbLower, "BB Lower", color=color.new(color.blue, 80), linewidth=1)

// Ğ¤Ğ¾Ğ½Ñ‹
bgWatchLong = showWatchBg and isWatchLongFinal ? color.new(color.green, 92) : na
bgWatchShort = showWatchBg and isWatchShortFinal ? color.new(color.red, 92) : na
bgTriggerLong = showTriggerBg and (isTriggerLongFinal or isFITlongFinal) ? color.new(color.green, 85) : na
bgTriggerShort = showTriggerBg and (isTriggerShortFinal or isFITshortFinal) ? color.new(color.red, 85) : na

bgcolor(bgWatchLong, title="Watch Long Background")
bgcolor(bgWatchShort, title="Watch Short Background")
bgcolor(bgTriggerLong, title="Trigger Long Background")
bgcolor(bgTriggerShort, title="Trigger Short Background")

// ĞœĞµÑ‚ĞºĞ¸ Watch
if isWatchLongFinal and barstate.islast
    label.new(bar_index, low, "âš¡WATCH LONG\nS:" + str.tostring(watchScoreLong), 
              style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

if isWatchShortFinal and barstate.islast
    label.new(bar_index, high, "âš¡WATCH SHORT\nS:" + str.tostring(watchScoreShort), 
              style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// ĞœĞµÑ‚ĞºĞ¸ Trigger Path A
if isTriggerLongFinal and barstate.islast
    label.new(bar_index, low, "ğŸš€ TRIGGER L\nS:" + str.tostring(watchScoreLong), 
              style=label.style_label_up, color=color.lime, textcolor=color.black, size=size.normal)

if isTriggerShortFinal and barstate.islast
    label.new(bar_index, high, "ğŸš€ TRIGGER S\nS:" + str.tostring(watchScoreShort), 
              style=label.style_label_down, color=color.fuchsia, textcolor=color.white, size=size.normal)

// ĞœĞµÑ‚ĞºĞ¸ FIT Path B
if isFITlongFinal and barstate.islast
    label.new(bar_index, low, "âš¡FIT LONG\nTR:" + str.tostring(trRange_ATR, "#.#") + " VolZ:" + str.tostring(volZ, "#.#"), 
              style=label.style_label_up, color=color.yellow, textcolor=color.black, size=size.normal)

if isFITshortFinal and barstate.islast
    label.new(bar_index, high, "âš¡FIT SHORT\nTR:" + str.tostring(trRange_ATR, "#.#") + " VolZ:" + str.tostring(volZ, "#.#"), 
              style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.normal)

// ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸
if showPanel and barstate.islast
    var table infoTable = table.new(position.top_right, 2, 15, border_width=1, bgcolor=color.new(color.black, 80), border_color=color.gray)
    
    // Watch Direction
    watchDir = isWatchLongFinal ? "LONG" : (isWatchShortFinal ? "SHORT" : "---")
    watchDirColor = isWatchLongFinal ? color.lime : (isWatchShortFinal ? color.red : color.gray)
    table.cell(infoTable, 0, 0, "Watch:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 0, watchDir, text_color=watchDirColor, text_size=size.small)
    
    // Score
    scoreDisplay = isWatchLongFinal ? str.tostring(watchScoreLong) : (isWatchShortFinal ? str.tostring(watchScoreShort) : "0")
    table.cell(infoTable, 0, 1, "Score:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 1, scoreDisplay, text_color=color.yellow, text_size=size.small)
    
    // Path Active
    pathActive = (isTriggerLongFinal or isTriggerShortFinal) ? "A-Trig" : ((isFITlongFinal or isFITshortFinal) ? "B-FIT" : "---")
    table.cell(infoTable, 0, 2, "Path:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 2, pathActive, text_color=color.aqua, text_size=size.small)
    
    // Compression
    table.cell(infoTable, 0, 3, "Compress:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(compressionSignsCount) + "/3 (" + (persistentCompression ? "âœ“" : "âœ—") + ")", 
               text_color=persistentCompression ? color.lime : color.gray, text_size=size.small)
    
    // BW Z / ATR% Z
    table.cell(infoTable, 0, 4, "BW Z:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 4, str.tostring(bbWidthZ, "#.##"), text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 5, "ATR% Z:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 5, str.tostring(atrPctZ, "#.##"), text_color=color.white, text_size=size.small)
    
    // Ribbon / Dist200
    table.cell(infoTable, 0, 6, "Ribbon:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 6, ribbonTight ? "âœ“" : "âœ—", text_color=ribbonTight ? color.lime : color.red, text_size=size.small)
    
    table.cell(infoTable, 0, 7, "Dist200:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 7, str.tostring(distTo200ATR, "#.##"), text_color=nearEMA200 ? color.lime : color.white, text_size=size.small)
    
    // Slope / Vol Dry
    table.cell(infoTable, 0, 8, "Slope:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 8, str.tostring(slope200, "#.###"), text_color=slope200 > 0 ? color.lime : color.red, text_size=size.small)
    
    table.cell(infoTable, 0, 9, "Vol Dry:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 9, volDry ? "âœ“" : "âœ—", text_color=volDry ? color.lime : color.red, text_size=size.small)
    
    // VolZ / CVD
    table.cell(infoTable, 0, 10, "VolZ:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 10, str.tostring(volZ, "#.##"), text_color=volSpike ? color.lime : color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 11, "CVD:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 11, cvdSlope > 0 ? "â†‘" : "â†“", text_color=cvdSlope > 0 ? color.lime : color.red, text_size=size.small)
    
    // FIT Metrics
    table.cell(infoTable, 0, 12, "TR/ATR:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 12, str.tostring(trRange_ATR, "#.#"), text_color=trRange_ATR >= fitTRmult ? color.lime : color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 13, "BB Exp:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 13, str.tostring(bbWidthExpansion, "#.##"), text_color=fitBBexpanded ? color.lime : color.white, text_size=size.small)
    
    // Cooldowns
    cooldownDisplay = cooldownCounterA > 0 ? "A:" + str.tostring(cooldownCounterA) : (cooldownCounterB > 0 ? "B:" + str.tostring(cooldownCounterB) : "Ready")
    table.cell(infoTable, 0, 14, "Cooldown:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 14, cooldownDisplay, text_color=(cooldownCounterA > 0 or cooldownCounterB > 0) ? color.orange : color.lime, text_size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ĞĞ›Ğ•Ğ Ğ¢Ğ«
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Path A Alerts
if isWatchLongFinal and barstate.isconfirmed
    alert("âš¡ WATCH LONG [A]: " + syminfo.ticker + " | Score=" + str.tostring(watchScoreLong) + " | BW_Z=" + str.tostring(bbWidthZ, "#.##"), alert.freq_once_per_bar)

if isWatchShortFinal and barstate.isconfirmed
    alert("âš¡ WATCH SHORT [A]: " + syminfo.ticker + " | Score=" + str.tostring(watchScoreShort) + " | BW_Z=" + str.tostring(bbWidthZ, "#.##"), alert.freq_once_per_bar)

if isTriggerLongFinal and barstate.isconfirmed
    alert("ğŸš€ TRIGGER LONG [A]: " + syminfo.ticker + " | Score=" + str.tostring(watchScoreLong) + " | Depth=" + str.tostring(distTo200ATR, "#.##") + "ATR", alert.freq_once_per_bar)

if isTriggerShortFinal and barstate.isconfirmed
    alert("ğŸš€ TRIGGER SHORT [A]: " + syminfo.ticker + " | Score=" + str.tostring(watchScoreShort) + " | Depth=" + str.tostring(distTo200ATR, "#.##") + "ATR", alert.freq_once_per_bar)

// Path B (FIT) Alerts
if isFITlongFinal and barstate.isconfirmed
    alert("âš¡ FIT LONG [B]: " + syminfo.ticker + " | TR/ATR=" + str.tostring(trRange_ATR, "#.#") + " | VolZ=" + str.tostring(volZ, "#.#") + " | BBexp=" + str.tostring(bbWidthExpansion, "#.#"), alert.freq_once_per_bar)

if isFITshortFinal and barstate.isconfirmed
    alert("âš¡ FIT SHORT [B]: " + syminfo.ticker + " | TR/ATR=" + str.tostring(trRange_ATR, "#.#") + " | VolZ=" + str.tostring(volZ, "#.#") + " | BBexp=" + str.tostring(bbWidthExpansion, "#.#"), alert.freq_once_per_bar)

// Simple alertconditions
alertcondition(isWatchLongFinal, "Watch Long [A]", "âš¡ WATCH LONG: {{ticker}}")
alertcondition(isWatchShortFinal, "Watch Short [A]", "âš¡ WATCH SHORT: {{ticker}}")
alertcondition(isTriggerLongFinal, "Trigger Long [A]", "ğŸš€ TRIGGER LONG: {{ticker}}")
alertcondition(isTriggerShortFinal, "Trigger Short [A]", "ğŸš€ TRIGGER SHORT: {{ticker}}")
alertcondition(isFITlongFinal, "FIT Long [B]", "âš¡ FIT LONG: {{ticker}}")
alertcondition(isFITshortFinal, "FIT Short [B]", "âš¡ FIT SHORT: {{ticker}}")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ğ’Ğ«Ğ¥ĞĞ”ĞĞ«Ğ• Ğ¡Ğ•Ğ Ğ˜Ğ˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(watchScoreLong, "Watch Score Long", display=display.data_window)
plot(watchScoreShort, "Watch Score Short", display=display.data_window)
plot(isWatchLongFinal ? 1 : 0, "Is Watch Long", display=display.data_window)
plot(isWatchShortFinal ? 1 : 0, "Is Watch Short", display=display.data_window)
plot(isTriggerLongFinal ? 1 : 0, "Is Trigger Long [A]", display=display.data_window)
plot(isTriggerShortFinal ? 1 : 0, "Is Trigger Short [A]", display=display.data_window)
plot(isFITlongFinal ? 1 : 0, "Is FIT Long [B]", display=display.data_window)
plot(isFITshortFinal ? 1 : 0, "Is FIT Short [B]", display=display.data_window)
plot(trueCompression ? 1 : 0, "True Compression", display=display.data_window)
plot(persistentCompression ? 1 : 0, "Persistent Compression", display=display.data_window)
plot(bbWidthZ, "BBWidth Z", display=display.data_window)
plot(atrPctZ, "ATR% Z", display=display.data_window)
plot(trRange_ATR, "TR/ATR", display=display.data_window)
plot(bbWidthExpansion, "BBWidth Expansion", display=display.data_window)
